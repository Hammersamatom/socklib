#include "include/socks.hpp"
#include "include/errors.hpp"
extern "C" {
	//#if __has_include(<unistd.h>) //SHOULD be true if POSIX, false otherwise
	#include <sys/socket.h> //general socket
	#include <unistd.h> //close(...) and unlink(...)
}

namespace sks {
	/*const struct {
		uint16_t major = 0;
		uint16_t minor = 0;
		uint16_t build = 0;
	} versionInfo;*/
	
	socket::socket(domain d, type t, int protocol) {
		m_sockFD = ::socket(d, t, protocol);
		//On error, -1 is returned, and errno is set appropriately.
		if (m_sockFD == -1) {
			//Error creating socket; check errno for:
			/*-----------------------------------------------------------------------------------------------------------------------\
			|     EACCES      | Permission to create a socket of the specified type and/or protocol is denied.                       |
			|  EAFNOSUPPORT   | The implementation does not support the specified address family.                                    |
			|     EINVAL      | Unknown protocol, or protocol family not available.                                                  |
			|     EINVAL      | Invalid flags in type.                                                                               |
			|     EMFILE      | Process file table overflow.                                                                         |
			|     ENFILE      | The system limit on the total number of open files has been reached.                                 |
			| ENOBUFS/ENOMEM  | Insufficient memory is available. The socket cannot be created until sufficient resources are freed. |
			| EPROTONOSUPPORT | The protocol type or the specified protocol is not supported within this domain.                     |
			\------------------------------------------------------------------------------------------------------------------------/
			Other errors may be generated by the underlying protocol modules. A catch-all should also be present for this.
			*/
			throw sysErr(errno);
		}
		//Socket created successfully by this line
		m_validFD = true;
	}
	
	socket::socket(int sockFD, domain d, type t, int protocol) {
		//We already have a socket fd, we have to figure out some info now
		//sd_is_socket(sockFD, d, t, -1); //Can be used to check if the fd is for a socket of given domain and type; I don't know if its POSIX so it stays commented-out
		
		m_sockFD = sockFD;
		m_validFD = true;
		m_domain = d;
		m_type = t;
		m_protocol = protocol;
	}
	
	socket::socket(socket&& s) {
		//this socket should be identical to other socket s
		//other socket should be left invalid
		std::swap(m_validFD, s.m_validFD);
		std::swap(m_sockFD, s.m_sockFD);
		std::swap(m_domain, s.m_domain);
		std::swap(m_type, s.m_type);
		std::swap(m_protocol, s.m_protocol);
	}
	
	socket::~socket() {
		//If we have just done a move operation on this socket, file descriptor should not be touched/read
		if (m_validFD) {
			//Close/disconnect/shutdown socket
			int e = close(m_sockFD);
			//On error, -1 is returned, and errno is set appropriately.
			if (e == -1) {
				//Error closing socket
				/*---------------------------------------------------------------------\
				| EBADF | fd isn't a valid open file descriptor.                       |
				| EINTR | The close() call was interrupted by a signal; see signal(7). |
				|  EIO  | An I/O error occurred.                                       |
				\----------------------------------------------------------------------/
				EBADF isn't checked since we personally handle the fd
				*/
				//throw sysErr(errno);
				//Throwing in a deconstructor is bad for reasons, so don't throw exceptions
			}
			
			//TODO: Fix-up and un-comment this
			//if (m_domain == unix && bound) {
			//	unlink(const char *pathname);
			//}
		}
	}
	
	void socket::bind(const address& address) {
		//Make sure domain of address matches that of this socket
		if (address.domain() != m_domain) {
			throw sysErr(EFAULT); //Bad Address, since domain mis-matched between address and this socket
		}
		//Do binding
		sockaddr_storage addr = address;
		int e = ::bind(m_sockFD, (sockaddr*)&addr, (socklen_t)address);
		//On error, -1 is returned, and errno is set appropriately.
		if (e == -1) {
			//NOTICE: This table (from man bind(2) isn't fully correct, EFAULT can be given if address has mismatching AF with socket)
			/*--------------------------------------------------------------------------\
			|   EACCES   | The address is protected, and the user is not the superuser. |
			| EADDRINUSE | The given address is already in use.                         |
			|   EBADF    | sockfd is not a valid descriptor.                            |
			|   EINVAL   | The socket is already bound to an address.                   |
			|  ENOTSOCK  | sockfd is a descriptor for a file, not a socket.             |
			\---------------------------------------------------------------------------/
			EBADF, ENOTSOCK aren't checked since we personally handle the fd
			*/
			//The following errors are specific to UNIX domain (AF_UNIX) sockets:
			/*--------------------------------------------------------------------------------------------------------------\
			|    EACCES     | Search permission is denied on a component of the path prefix. (See also path_resolution(7).) |
			| EADDRNOTAVAIL | A nonexistent interface was requested or the requested address was not local.                 |
			|    EFAULT     | addr points outside the user's accessible address space.                                      |
			|    EINVAL     | The addrlen is wrong, or the socket was not in the AF_UNIX family.                            |
			|     ELOOP     | Too many symbolic links were encountered in resolving addr.                                   |
			| ENAMETOOLONG  | addr is too long.                                                                             |
			|    ENOENT     | The file does not exist.                                                                      |
			|    ENOMEM     | Insufficient kernel memory was available.                                                     |
			|    ENOTDIR    | A component of the path prefix is not a directory.                                            |
			|     EROFS     | The socket inode would reside on a read-only file system.                                     |
			\---------------------------------------------------------------------------------------------------------------/
			EINVAL IS checked since the addressUnix constructor asks for length, but only for the first half since domain check is done seperately
			*/
			throw sysErr(errno);
		}
	}
	
	void socket::listen(int backlog) {
		int e = ::listen(m_sockFD, backlog);
		//On error, -1 is returned, and errno is set appropriately.
		if (e == -1) {
			/*-------------------------------------------------------------------------------\
			| EADDRINUSE | Another socket is already listening on the same port.             |
			|   EBADF    | The argument sockfd is not a valid descriptor.                    |
			|  ENOTSOCK  | The argument sockfd is not a socket.                              |
			| EOPNOTSUPP | The socket is not of a type that supports the listen() operation. |
			\--------------------------------------------------------------------------------/
			*/
			throw sysErr(errno);
		}
	}
	
	socket socket::accept() {
		sockaddr_storage sa;
		socklen_t salen;
		int peerFD = ::accept(m_sockFD, (sockaddr*)&sa, &salen);
		//On error, -1 is returned, and errno is set appropriately.
		if (peerFD == -1) {
			throw sysErr(errno);
		}
		//We have the file descriptor, construct a socket (class) around it
		socket peer(peerFD, m_domain, m_type, m_protocol);
		return peer;
	}

	void socket::connect(const address& address) {
		sockaddr_storage addr = address;
		int e = ::connect(m_sockFD, (sockaddr*)&addr, (socklen_t)address);
		//On error, -1 is returned, and errno is set appropriately.
		if (e == -1) {
			throw sysErr(errno);
		}
	}
	
	void socket::send(std::vector<uint8_t> data) {
		size_t sent = 0;
		//send may not send all data at once, so we have a loop here
		while (sent < data.size()) {
			ssize_t r = ::send(m_sockFD, data.data() + sent, data.size() - sent, 0); //Flags of 0 only for now, might open up later
			//On success, these calls return the number of characters sent. On error, -1 is returned, and errno is set appropriately.
			if (r == -1) {
				throw sysErr(errno);
			}
			sent += r; //We sent r bytes with this send
		}
	}
	void socket::send(std::vector<uint8_t> data, address& to) {
		sockaddr_storage addr = to;
		size_t sent = 0;
		//send may not send all data at once, so we have a loop here
		while (sent < data.size()) {
			ssize_t r = ::sendto(m_sockFD, data.data() + sent, data.size() - sent, 0, (sockaddr*)&addr, (socklen_t)to); //Flags of 0 only for now, might open up later
			if (r == -1) {
				throw sysErr(errno);
			}
			sent += r; //We sent r bytes with this send
		}
	}
	
	std::vector<uint8_t> socket::receive(size_t bufSize) {
		std::vector<uint8_t> buffer(bufSize);
		ssize_t r = recv(m_sockFD, buffer.data(), buffer.size(), 0); //Flags of 0 only for now, might open up later
		if (r == -1) {
			throw sysErr(errno);
		}
		buffer.resize(r); //These calls return the number of bytes received
		return buffer;
	}
	std::vector<uint8_t> socket::receive(address& from, size_t bufSize) {
		std::vector<uint8_t> buffer(bufSize);
		sockaddr_storage sa;
		socklen_t salen;
		ssize_t r = recvfrom(m_sockFD, buffer.data(), buffer.size(), 0, (sockaddr*)&sa, &salen); //Flags of 0 only for now, might open up later
		if (r == -1) {
			throw sysErr(errno);
		}
		buffer.resize(r); //These calls return the number of bytes received
		createAddress(sa, salen, from);
		return buffer;
	}



	std::pair<socket, socket> socketPair(domain d, type t, int protocol) {
		//Create two sockets with given params
		int FDs[2];
		int e = socketpair(d, t, protocol, FDs);
		if (e == -1) {
			throw sysErr(errno);
		}
		//We have two socket file descriptors, wrap into classes then put into return pair
		return std::pair<socket, socket>{ socket(FDs[0], d, t, protocol), socket(FDs[1], d, t, protocol) };
	}
};
